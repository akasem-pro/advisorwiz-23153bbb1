// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

export const SUPABASE_URL = "https://gkymvotqrdecjjymmmef.supabase.co";
export const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdreW12b3RxcmRlY2pqeW1tbWVmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE0NzA5NTIsImV4cCI6MjA1NzA0Njk1Mn0.j7Os6vxWOT35pC3rLiDuMuDty7VJTWvw7khbZpPLijY";

// Create the Supabase client with improved configuration
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      storage: localStorage
    },
    global: {
      headers: {
        'X-App-Version': '1.0.0',
      },
      // Implement a custom fetch with retry logic
      fetch: async (url: RequestInfo | URL, options: RequestInit = {}) => {
        const maxRetries = 2;
        let retries = 0;
        
        // Add cache busting for auth endpoints
        const fullUrl = new URL(url.toString());
        if (fullUrl.pathname.includes('auth')) {
          fullUrl.searchParams.set('_', Date.now().toString());
        }
        
        while (retries <= maxRetries) {
          try {
            const response = await fetch(fullUrl.toString(), {
              ...options,
              credentials: 'same-origin',
              headers: {
                ...(options.headers || {}),
                'Cache-Control': 'no-cache, no-store',
                'Pragma': 'no-cache'
              }
            });
            
            if (response.ok || response.status >= 400) {
              return response;
            }
            
            throw new Error(`Request failed with status ${response.status}`);
          } catch (error) {
            retries++;
            
            if (retries > maxRetries) {
              console.error("Max retries reached for request:", fullUrl.toString());
              throw error;
            }
            
            // Exponential backoff
            const delay = Math.min(1000 * (2 ** retries), 5000);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
        
        // This should never be reached because of the throw in the loop
        throw new Error("Failed to fetch after retries");
      }
    }
  }
);

// Add a helper function to check Supabase connection
export const checkSupabaseConnection = async () => {
  try {
    // More reliable approach: Try a very simple query that doesn't require auth
    // It's lightweight and will indicate if we can reach Supabase
    const { error } = await supabase.from('profiles').select('id', { count: 'exact', head: true }).limit(1);
    
    // If there's a network error, it will have a specific signature
    if (error && (error.message.includes('network') || error.message.includes('fetch'))) {
      console.error('Supabase connection error (network):', error.message);
      return false;
    }
    
    // Other errors (like permission denied) still mean we have connectivity
    // Just not the right permissions - that's still "online"
    console.log('Supabase connection successful');
    return true;
  } catch (error: any) {
    console.error('Failed to check Supabase connection:', error);
    // Check if it's specifically a network error
    if (error.message && (
        error.message.includes('fetch') || 
        error.message.includes('network') ||
        error.message.includes('connection') ||
        error.message.includes('offline')
      )) {
      return false;
    }
    // For other errors, we're still likely connected
    return navigator.onLine;
  }
};
